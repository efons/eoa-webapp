options = leafletOptions(pane = "polygons")
) %>%
addCircleMarkers(
group = "circles",
layerId = data_sub$rmc_id,
lng = data_sub$long,
lat = data_sub$lat,
radius = getRadius(),
weight = 1,
opacity = 0.6,
popup = content,
fill = T,
fillColor = getColor(),
fillOpacity = 0.6,
options = leafletOptions(pane = "markers")
) %>%
addLegendCustom(
position = "topright",
opacity = 1,
borders = c("white", 'white', 'white', "white"),
colors = colors_bio,
labels = c(
"Likely Intact",
"Possibly Intact",
"Likely Altered",
"Very Likely Altered"
),
sizes = c(rep(12, 4)),
shapes = rep("circle", 4),
title = as.character(filter_name)
)
#if(input$show_creeks == "yes")
#{
#leafletProxy("map_sites") %>%
# addPolylines(data=creeks, weight=1, color="black")
#}
}
})
# Watershed-specific info that appears when the user clicks on a polygon
observe({
click <- input$map_sites_shape_click
if (is.null(click))
return()
else
output$ws_info <- renderText({
paste("Watershed-specific info for", click$id)
})
})
# Site-specific info that appears when the user clicks on a marker
observe({
click <- input$map_sites_marker_click
if (is.null(click))
return()
else
output$site_info <- renderText({
paste("Site-specific info for", click$id, "(", df_bio$ws[which(df_bio$rmc_id == click$id)], ")")
})
output$table_site_onClick <- renderTable({
slct_col <-
colnames(df_bio[, c(1, 3, 29, 30, 7, 11, 12, 13, 14, 15, 16, 17, 18, 19, 23, 31, 32)])
d <- df_bio %>% dplyr::select(slct_col) %>%
filter(rmc_id == click$id) %T>%
{
names(.) <-
as.character(param_names[match(slct_col, param_names$dataname), 1])
} %>%
t()
return(d)
}, rownames = T, colnames = F, bordered = T, align = 'c')
})
## POC data
############################################################################################################################
# Plot for POC
data_sub_poc <- reactive({
poc_contaminant <- input$poc_contaminant
sites_POC <- df_POC %>%
dplyr::filter(year >= input$poc_yr[1] &
year <= input$poc_yr[2])
if (poc_contaminant == "hg")
{
sites_POC <-
sites_POC %>% dplyr::mutate(selected_cont = hg_mg_kg) %>%
dplyr::mutate(conc_cat = as.factor(hg_conc_cat))
}
else {
sites_POC <-
sites_POC %>% dplyr::mutate(selected_cont = pcbs_mg_kg) %>%
dplyr::mutate(conc_cat = as.factor(pcb_conc_cat))
}
return(sites_POC)
})
output$plot_poc_1 <- renderPlot({
data_sub_poc <- data_sub_poc()
n <- length(unique(conc_cat))
colors <- if (n == 3) {
colors_Hg[2:4]
} else {
colors_PCB
}
ggplot(data = data_sub_poc, aes(x = factor(city), fill = conc_cat)) + geom_bar() +
scale_fill_manual(values = colors) +
theme(axis.text.x = element_text(angle = 90, hjust = 1),
legend.title = element_blank()) +
xlab("City")
})
# MAP for POC
output$map_poc <- renderLeaflet({
leaflet() %>%
addProviderTiles(providers$Esri.WorldTopoMap) %>%
setView(lng = -122,
lat = 37.4,
zoom = 10)
})
# Update map with user inputs
observe({
# wait for POC menu to be selected
req(input$menu_items == "poc")
poc_contaminant <- input$poc_contaminant
sites_poc <-
df_POC %>%  dplyr::filter(year >= input$poc_yr[1] &
year <= input$poc_yr[2])
content_poc <- paste(
sep = "<br/>",
"<b>City:</b>",
sites_poc$city,
"<b>Concentration:</b>",
if (poc_contaminant == "hg") {
paste(sites_poc$hg_mg_kg, "mg/kg")
} else
paste(sites_poc$pcbs_mg_kg, "mg/kg"),
"<b>Date:</b>",
sites_poc$samp_date
)
getRadius_poc <- function(df) {
if (poc_contaminant == "hg") {
rad <-
500 * (df$hg_mg_kg + 1) * (12 - as.numeric(df$hg_conc_cat)) / max(df$hg_mg_kg)
}
else
rad <-
30000 * (df$pcbs_mg_kg + 1) * (4.2 - as.numeric(df$pcb_conc_cat)) / max(df$pcbs_mg_kg)
rad
}
getColor_poc <- function(df) {
if (poc_contaminant == "hg") {
col <- df$hg_col
}
else
col <- df$pcb_col
col
}
lab_poc <-
if (poc_contaminant == "hg") {
levels(sites_poc$hg_conc_cat)[2:4]
} else
levels(sites_poc$pcb_conc_cat)
colors_poc <-
if (poc_contaminant == "hg") {
colors_Hg[2:4]
} else
colors_PCB
leafletProxy("map_poc") %>% clearMarkers() %>% clearShapes() %>% clearControls() %>%
addCircleMarkers(
lng = sites_poc$long,
lat = sites_poc$lat,
radius = 5,
color = getColor_poc(sites_poc),
weight = 1,
popup = content_poc,
opacity = 0.7,
fillOpacity = 0.5
) %>%
addLegend(
"topright",
colors = colors_poc,
labels = lab_poc,
title = "Color Key",
layerId = "colorLegend"
)
})
## Continuous water quality
#############################################################################################################################
# update inputs - sub-watersheds - sites
output$map_wq <-  renderLeaflet({
leaflet() %>%
addProviderTiles(providers$Esri.WorldTopoMap) %>%
setView(lng = -122,
lat = 37.3,
zoom = 9) %>%
addMapPane(name = "polygons", zIndex = 410) %>%
addMapPane(name = "markers", zIndex = 420)
})
# update based on user input
observe({
req(input$menu_items == "con_wq")
popup <- paste(
sep = "<br/>",
"<b>Site:</b>",
sites_cWQ$site_id,
"<b>Watershed:</b>",
sites_cWQ$ws,
"<b>Continuous Water Quality Sampling in:</b>",
sites_cWQ$sampl_dates_wq,
"<b>Continuous Temperature Sampling in:</b>",
sites_cWQ$sampl_dates_temp
)
get_color_wq <- function() {
if (input$wq_plots == "Continuous Temperature") {
if (input$temp_param == "avDayTemp") {
threshold <-
temp_thresholds[temp_thresholds$param == "avDayTemp", "thresh"]
df_sub <- df_temp_7DAVG %>%
filter(year >= input$wq_yr[1] & year <= input$wq_yr[2])
exc_ratio <- sapply(sites_cWQ$site_id,
function(x)
sum(df_sub$avDayTemp[which(df_sub$site_id == x)] > threshold)
/ length(df_sub$avDayTemp[which(df_sub$site_id == x)]))
return(colors_temp[signif(exc_ratio, 1) * 10 + 1])
}
if (input$temp_param == "avWeek") {
threshold <-
temp_thresholds[temp_thresholds$param == "avWeek", "thresh"]
df_sub <- df_temp_MWAT %>%
filter(year >= input$wq_yr[1] & year <= input$wq_yr[2])
exc_ratio <- sapply(sites_cWQ$site_id,
function(x)
sum(df_sub$avWeek[which(df_sub$site_id == x)] > threshold)
/ length(df_sub$avWeek[which(df_sub$site_id == x)]))
return(colors_temp[signif(exc_ratio, 1) * 10 + 1])
}
}
else
return("black")
}
get_weight <- function() {
return(sapply(sheds$SYSTEM, function(x) {
if (x == input$wq_ws) {
5
} else{
1
}
}))
}
#shapes: 15 = square, 16= circle, 17 = triangle
leafletProxy("map_wq")  %>% clearMarkers() %>% clearShapes() %>% clearControls() %>%
addPolygons(
data = sheds,
layerId = sheds$SYSTEM,
weight = get_weight(),
smoothFactor = 0.5,
opacity = 0.6,
fill = T,
fillOpacity = 0.1,
label = sheds$SYSTEM,
highlightOptions = highlightOptions(
color = "white",
weight = 3,
bringToFront = TRUE
),
options = leafletOptions(pane = "polygons")
) %>%
#addCustomMarkers(data= sites_cWQ, lng=sites_cWQ$long, lat=sites_cWQ$lat,
#                size=20, bg = c("blue", "orange","purple"),
#               shapes=c(21,22,24), icon_group = sites_cWQ$marker_group,
#              popup = popup) %>%
addCircleMarkers(
data = sites_cWQ,
lng = sites_cWQ$long,
lat = sites_cWQ$lat,
radius = 5,
opacity = 1,
fillOpacity = 0.8,
color = get_color_wq(),
popup = popup,
options = leafletOptions(pane = "markers")
) %>%
#addLegendCustom(position="topright", colors=c("blue","orange","purple"),
#               shapes = c("square", "circle", "triangle"),
#              labels=c("Continuous WQ", "Continuous Temperature", "Both"),
#             sizes=c(10,10,10), borders=rep(2,3))
addLegend(
"topleft",
title = "exceedance/record ratio",
colors = colors_temp,
labels = c(
"0",
"0-0.1",
"0.1-0.2",
"0.2-0.3",
"0.3-0.4",
"0.4-0.5",
"0.5-0.6",
"0.6-0.7",
"0.7-0.8",
"0.8-0.9",
"0.9-1.0"
)
)
})
time_plot_function <- function(data_sub_temp, param) {
if (nrow(data_sub_temp) > 0) {
x_lims <-
c(as.Date(paste(
min(data_sub_temp$year), "-01-01", sep = ""
)), as.Date(paste(
max(data_sub_temp$year), "-12-31", sep = ""
)))
#if (param== "ConTemp"){
# p <- ggplot(data=data_sub_temp, aes(x=date, y=ctemp_c, col=site_id)) + geom_line(size=0.3) + ylim(c(0,30))  + ylab("Temperature (\u00B0C)") + xlab("Date")  + scale_x_datetime(breaks=date_breaks("1 year"), labels=date_format("%b-%y")) +
#geom_hline(yintercept = 24, linetype=2, col = "red") +
#theme_bw()
#}
if (param == "avDayTemp") {
threshold <-
temp_thresholds[temp_thresholds$param == "avDayTemp", "thresh"]
p <-
ggplot(data = data_sub_temp, aes(x = date, y = avDayTemp)) + geom_line(aes(col =
site_id, group = grp))  +
ylim(c(0, 30))  + ylab("Average Daily Temperature (\u00B0C)") +
xlab("Date")  +   scale_x_date(
date_breaks = "3 months",
labels = date_format("%b-%Y"),
date_minor_breaks = "1 month",
limits = x_lims,
expand = c(0, 0)
) +
theme_bw() +
geom_hline(yintercept = threshold,
linetype = 2,
col = "red")
}
if (param == "avWeek") {
threshold <-
temp_thresholds[temp_thresholds$param == "avWeek", "thresh"]
p <-
ggplot(data = data_sub_temp, aes(x = day1week, y = avWeek, col = site_id)) + geom_point(aes(shape =
site_id), size = 2) +
ylim(c(0, 30))  + ylab("MWAT (\u00B0C)") + xlab("Date") +
scale_x_date(
date_breaks = "3 months",
labels = date_format("%b-%Y"),
date_minor_breaks = "1 month",
limits = x_lims,
expand = c(0, 0)
) +
geom_hline(yintercept = threshold,
linetype = 2,
col = "red") +
scale_shape_manual(values = seq(1, 15, 1)) +
theme_bw()
}
return(p)
}
else {
NULL
}
}
temp_timeseries_1 <- reactive({
if (input$temp_param == "avDayTemp") {
data_sub_temp <- df_temp_7DAVG %>%
dplyr::filter(year >= input$wq_yr[1] &
year <= input$wq_yr[2],
ws == input$wq_ws,
plot_cat == 1)
return(time_plot_function(data_sub_temp = data_sub_temp, param = input$temp_param))
}
if (input$temp_param == "avWeek") {
data_sub_temp <- df_temp_MWAT %>%
dplyr::filter(year >= input$wq_yr[1] &
year <= input$wq_yr[2],
ws == input$wq_ws,
plot_cat == 1)
return(time_plot_function(data_sub_temp = data_sub_temp, param = input$temp_param))
}
})
temp_timeseries_2 <- reactive({
if (input$temp_param == "avDayTemp") {
data_sub_temp <- df_temp_7DAVG %>%
dplyr::filter(year >= input$wq_yr[1] &
year <= input$wq_yr[2],
ws == input$wq_ws,
plot_cat == 2)
p <-
time_plot_function(data_sub_temp = data_sub_temp, param = input$temp_param)
}
if (input$temp_param == "avWeek") {
data_sub_temp <- df_temp_MWAT %>%
dplyr::filter(year >= input$wq_yr[1] &
year <= input$wq_yr[2],
ws == input$wq_ws,
plot_cat == 2)
p <-
time_plot_function(data_sub_temp = data_sub_temp, param = input$temp_param)
}
return(p)
})
output$temp_timeseries_1 <- renderPlot({
p <- temp_timeseries_1()
return(p)
})
output$temp_timeseries_2 <- renderPlot({
p <- temp_timeseries_2()
return(p)
})
# Boxplots
boxplot_function <-
function(data_sub_wq,
param,
x_param = "year",
plot_cat = 1) {
if (nrow(data_sub_wq) > 0) {
data_sub_wq <- data_sub_wq[data_sub_wq$plot_cat == plot_cat, ]
if (nrow(data_sub_wq) > 0) {
threshold <-
MRP_threshold[match(colnames(data_sub_wq)[ncol(data_sub_wq)], MRP_threshold$label), 'value_sup']
df_tempo <-
data.frame(x_var = as.factor(data_sub_wq[, which(colnames(data_sub_wq) ==
x_param)]),
y_var = data_sub_wq[, which(colnames(data_sub_wq) ==
param)])
p <-
ggplot(data = df_tempo, aes(x = x_var, y = y_var)) + geom_boxplot(col =
rgb(0, 0, 1, 0.6)) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
xlab(x_param) + ylab(colnames(data_sub_wq)[ncol(data_sub_wq)]) +
geom_hline(
yintercept = threshold,
lty = 2,
col = "red",
lwd = 1
) +
stat_summary(
fun.data = give_tot,
geom = "text",
fun.y = median,
position = position_dodge(width = 0.75)
)
return(p)
}
} else
return(NULL)
}
wq_data_sub <- reactive({
param <- input$wq_param
season <- input$wq_season
ws <- input$wq_ws
season <- input$wq_season
data_sub_wq <- df_wq %>%
dplyr::filter(
year >= input$wq_yr[1] & year <= input$wq_yr[2],
ws %in% input$wq_ws,
season == input$wq_season
)
data_sub_wq <-
cbind(data_sub_wq, data_sub_wq[, which(colnames(data_sub_wq) == param)])
parameter_name <-
as.character(MRP_threshold[match(param, MRP_threshold$param), 'label'])
colnames(data_sub_wq)[ncol(data_sub_wq)] <- parameter_name
return(data_sub_wq)
})
output$wq_boxplot_1 <- renderPlot({
data_sub_wq <- wq_data_sub()
param <- colnames(data_sub_wq)[ncol(data_sub_wq)]
return(
boxplot_function(
data_sub_wq = data_sub_wq,
param = param,
plot_cat = 1,
x_param = "site_id"
)
)
})
output$wq_boxplot_2 <- renderPlot({
data_sub_wq <- wq_data_sub()
param <- colnames(data_sub_wq)[ncol(data_sub_wq)]
return(
boxplot_function(
data_sub_wq = data_sub_wq,
param = param,
plot_cat = 2,
x_param = "site_id"
)
)
})
# Beanplots < boxplots now
output$wq_beanplot_1 <- renderPlot({
data_sub_wq <- wq_data_sub()
param <- colnames(data_sub_wq)[ncol(data_sub_wq)]
return(
boxplot_function(
data_sub_wq = data_sub_wq,
param = param,
plot_cat = 1,
x_param = "year"
)
)
})
output$wq_beanplot_2 <- renderPlot({
data_sub_wq <- wq_data_sub()
param <- colnames(data_sub_wq)[ncol(data_sub_wq)]
return(
boxplot_function(
data_sub_wq = data_sub_wq,
param = param,
plot_cat = 2,
x_param = "year"
)
)
})
})
shinyApp(ui)db, server
shinyApp(ui_db, server)
